<<java2 memo summary>>

* 메소드 오버로딩 (overloading)
> 같은 이름의 메소드를 매개변수의 타입 혹은 개수를 다르게 해서 정의하는 행위
[리턴 타입이나 매개변수 이름과는 무관]

* 변수의 생명주기
> 같은 영역에서 같은 이름의 변수는 생성할 수 없다

* 지역변수 ( local variable ) 
> 해당 지역내에서만 사용 가능한 변수
> 메소드 안에 선언된 변수
> 메소드가 호출되면 메모리에 할당되고, 메소드 호출이 종료되면 메모리에서 해제된다

메소드의 매개변수나 지역변수는 해당 메소드 안에서만 사용 가능
인자로 넘겨받은 값을 잠시 복사하여 해당 메소드 영역 안에서 사용하다가
메소드 사용이 끝나면 매개변수는 메모리에서 해제되므로 값을 복사해서 사용하고 다시 값으로 되돌려주는 방식
그 값을 변수에 담아주면 메소드 사용이 끝나고 다른 영역에서도 사용 가능


* 클래스 (class)
> 사용자가 만드는 새로운 유형의 자료형(type)
[여러가지 타입의 값을 한 번에 저장할 수 있는 확장된 배열 개념]
[여러개의 값을 담아 놓을 수 있다, 메소드도 넣어 놓을 수 있다]

* 클래스의 선언 및 정의
class 클래스 이름{

}

* 생성자 
> 클래스이름(){}
[메소드랑 똑같지만 이미 메모리에 객체를 등록시켜주는 기능이 정해져 있으므로
  return 사용이 불가능하며, 생성자라고 부름]
[생성자를 정의한 것이 없다면 알아서 기본 생성자가 추가되지만,
  만약 생성자를 직접 정의한 것이 있다면 기본 생성자를 추가해주지 않으므로
  기본 생성자와 초기화 생성자를 모두 쓰고 싶다면 명시적으로 오버로딩 해주어야 한다]

* 초기화 생성자
> 클래스 이름(값, 값,값...)
[해당 클래스 내의 변수에 값을 넣어주면서 동시에 메모리에 할당시켜주는 생성자]
[객체화를 하면서 동시에 초기값도 설정하고 싶을 때 쓴다]

* 기본 생성자 : 객체화의 기능
* 초기화 생성자 : 객체화 + 초기값 설정

* this
	자기 자신 객체를 의미

* static 제어자
	static 변수 : 모든 객체가 동일한 값을 공유 
	[클래스명.변수명] 으로 사용하는 것이 바람직

	static 메소드 : 모든 객체에 동일하게 동작함
	[클래스명.메소드명()] 사용

* 접근 제어자 ( access modifier ) 
> 패키지, 클래스 영역에 대한 접근 권한을 부여
	
		패 o 클 o  /  패 o 클 x / 패 x 클 x
public	o		o		o
default	o		o		x
protected	o		x		x(자식은 가능)
private	o		x		x


* 게터와 세터(getters and setters)
> private으로 설정된 변수들은 다른 클래스에서 접근이 안된다
따라서 public으로 설정된 메소드를 통해 우회적으로 접근을 해야한다
이때 변수에 값을 설정하는 메소드를 setter,
       변수에 값을 가져오는 메소드를 getter라고 함

[변수에 값을 직접 저장하지 못하게 함으로써 유효한 값이 들어왔는지
검사를 할 수 있으며 안정성을 높일 수 있다]

* 객체타입배열
> 배열은 배열인데 요소로 객체가 들어있는 배열
[한 번 접근했을 때의 결과가 객체라고 생각하고 활용한다]

* flag변수
> 특정 위치까지 들어왔는지 아닌지 확인하기 위한 변수

* 상속(inheritance)
> 부모 클래스에 있는 멤버들을 자식 클래스에서 자유롭게 활용하고싶을때 사용하는 문법

public class 자식클래스명 extends 부모클래스명{


}

* 오버라이딩(overriding)
> 상속과정에서 부모 메소드를 자식에서 재정의하는것
[부모타입의 객체에서 메소드가 사용 -> 부모에서 정의한대로 기능]
[자식타입의 객체에서 메소드가 사용 -> 자식에서 재정의한대로 기능]

<> ** 오버로딩(overloading) **
> 메소드 이름은 같지만 매개변수의 개수가 다르거나 타입을 다르게 정의하는 것

* 다형성(polymorphism)을 구현하는 요소
> 오버라이딩, 오버로딩
[하나의 모양으로 다르게 동작하는 현상]


* @~ (어노테이션 주석)
> 컴퓨터가 보는 설명
> 의도적으로 오류를 발생시켜줌으로써 실수를 줄일 수 있다

* super
> 부모클래스를 의미
> 부모클래스안에 있는 메소드를 사용할 때 super.하고 사용

[자식 생성자를 호출하면 반드시 부모의 생성자를 먼저 호출하고 ,
  그 다음 자식 생성자가 호출이 됨]
[만약 상속을 받았는데, 오류가 나면 부모의 기본 생성자가 정의되었는지 확인]

* 업캐스팅과 다운캐스팅
* 업캐스팅
> 자식타입 -> 부모타입
[업캐스팅된다면 자식에서 새롭게 정의한 멤버는 사용 불가능
 그러나 자식에서 재정의한 메소드는 재정의한대로 기능을 함]

* 다운캐스팅
> 부모타입 -> 자식타입
[업캐스팅된 객체를 다시 자식타입으로 되돌리는 행위]
[못썼던 멤버들을 다시 활용 가능]

* 자바의 모든 클래스는 Object라는 클래스를 상속받음
* Object : 최상위 클래스

* 추상 클래스(abstract class)
> 클래스는 클래스인데 추상메소드를 가지고 있는 클래스

* 추상 메소드(abstract method)
> 메소드의 이름과 리턴타입만 선언되어있고 기능은 정의되어 있지 않은 메소드

[추상클래스를 상속받은 클래스에게 오버라이딩을 강제하기 위해 사용한다]
> 추상클래스를 상속받은 자식에게 오류가 나지 않게 하는 법
1. 추상메소드를 모두 오버로딩
2. 자식도 추상클래스화

+[추상클래스는 메모리에 미구현된 멤버가 존재하므로 객체화가 불가능]

* 인터페이스(interface)
> 추상클래스는 추상클래스인데, 추상메소드만 존재하는 추상클래스
> implements를 통해 상속을 받음
>  여러 클래스를 동시에 상속을 받을 수 있다
[ 자바는 원칙적으로 모호성이 발생할 수 있기 때문에 다중상속을 허용하지 않지만
 인터페이스 문법이 추가되며 사실상 다중 상속을 허용]


* 내부 클래스 ( inner class ) 
> 클래스 안에 정의된 클래스 // 파일 안에 파일
(1) 인스턴스 클래스
(2) 스태틱 클래스
(3) 지역 클래스
(4) 익명 클래스

[A라는 클래스에서 b라는 기능이 자주 필요한 상황
 그런데 b기능은 B클래스를 만들면 쉽게 유지보수 관리가 가능
 그런데 B라는 클래스는 굳이 다른 클래스에서는 필요가 없고
 A안에서만 필요하다면 A클래스 안 B클래스를 정의하여 자유롭게 사용

* 익명클래스(anonymous class)
해석 -> 클래스나 인터페이스를 상속받은 이름없는 클래스를 업캐스팅해서 씀
업캐스팅해서 쓰므로 새 멤버를 넣는것은 무의미
오버라이딩을 많이하며 일회성으로 사용하기 위해 익명 클래스를 활용

* API(Application Programming Interface)
> 프로그램을 제작하는데 사용할 수 있는 응용 프로그램 *도구*

외부 API
> 카카오지도, 문자보내기

내부 API
> 자바에서 자체적으로 제공하는 클래스
ex) Wrapper, Object, String

* 랩퍼클래스(Wrapper Class)
> 기본자료형(int, char, double, boolean..)을 감싸는 클래스

	자료형		클래스
	int			Integer
	double		Double
	char			Character
	boolean		Boolean
	...			...

* Object 클래스
	
- equals() -
> 해당 객체의 내용이 같을 때 true , 아닐 때 false가 나오도록
   재정의하여 사용 가능
- hashCode() -
> 해당 객체가 물리적으로는 다른 객체지만 내용상 동일한 객체를 
   나타내고자 할 때 재정의하여 사용
- toString() -  
> 해당 객체를 출력할 때 출력되는 문자열 값을 설정할 때 사용

* String 클래스
> 문자열과 관련된 다양한 메소드를 사용할 수 있다
length(문자열) : 문자열 길이가 리턴
charAt(인덱스) : 문자열의 인덱스에 해당하는 문자가 리턴
indexOf(문자) : 문자열의 문자의 인덱스번호를 리턴
substring() : 문자열을 자른 문자열을 리턴
split() : 문자열을 쪼개서 문자열들이 들어있는 배열을 리턴
join() : 배열 속 문자열 요소들을 연결한 하나의 문자열을 리턴


